<script setup lang="ts">
import {ProjectHelper} from "~/helper/ProjectHelper";
import type {DroppableProps} from "~/models/DroppableProps";
import DroppableComponent from "~/components/DraggableComponents/Layout/DroppableComponent.vue";
import type {IComponentFactory} from "~/models/interfaces/IComponentFactory";
import {DragDropHelper} from "~/helper/DragDropHelper";
import {nextTick, onMounted, onUnmounted, ref, type Ref} from "vue";
import type {TItemContextMenu} from "~/models/types/TItemContextMenu";
import {ApiContainer} from "~/services/api/ApiContainer";
import {EApiKeys} from "~/models/enum/EApiKeys";
import type {IComponentService} from "~/services/api/interfaces/IComponentService";
import {DIContainer} from "~/DIContainer/DIContainer";
import {EServiceKeys} from "~/models/enum/EServiceKeys";
import type {ComponentFactory} from "~/models/interfaces/ComponentFactory";
import type {LocalStorageService} from "~/services/LocalStorageService";
import type {INotifyManager} from "~/models/interfaces/INotifyManager";
import {LoadingManager} from "~/manager/LoadingManager";
import type {TFile} from "~/models/types/TFile";
import type {IDroppableComponent} from "~/models/IDroppableComponent";

const emit = defineEmits(['updateComponents']);
const props = defineProps({
  componentFactory:{
    required: true,
    type: Object as PropType<ComponentFactory>
  }
})
const componentFactory = ref(props.componentFactory);
const components = defineModel<IComponentFactory[]>('components');
const selectedComponent = defineModel<IComponentFactory>('selectedComponent');
const selectedProject = defineModel<IProject>('project');
const selectedFile = defineModel<TFile>('file');

const contextMenu = ref();

const draggedComponentIndex: Ref<number|null> = ref(null);
const draggedFrom: Ref<any> = ref(null);
const dragOverIndex: Ref<any> = ref(null);

const componentService: IComponentService = ApiContainer.getService<IComponentService>(EApiKeys.ComponentService);
const localStorageService = DIContainer.getService<LocalStorageService>(EServiceKeys.LocalStorageService);
const notifyManager = DIContainer.getService<INotifyManager>(EServiceKeys.NotifyManager);

const rootComponents = computed(() => {
  return components.value.filter(component => (!component?.parentId || component?.parentId < 1));
});
const getChildren = (parentId) => {
  return components.value.filter(component => component.parentId === parentId);
};

const itemsContextComponent: Ref<TItemContextMenu[]> = ref([
  {label: 'Modifica', icon: 'fa fa-pencil', command: () => handleComponentClick(selectedComponent.value as IComponentFactory)},
  {label: 'Duplica', icon: 'fa fa-copy', command: () => selectedComponent.value && duplicateComponent(selectedComponent.value)},
  {label: 'Cancella', icon: 'fa fa-trash', command: () => removeComponent()},
]);

//#
const addComponent = async (component: IComponentFactory, targetComponents: IComponentFactory[]) => {
  try {
    LoadingManager.getInstance().start();

    if (Array.isArray(targetComponents)) {
      let newFactoryComponent = componentFactory.value.createElement(component);

      const parentId = ProjectHelper.findParentId(component, targetComponents);
      newFactoryComponent.configure({
        ...component,
        type: newFactoryComponent?.constructor?.name || '',
        fileId: selectedFile.value?.id,
        order: ProjectHelper.getComponentOrder(parentId, targetComponents),
        parentId: parentId,
      });

      const resultCreateComponent = await componentService.createComponent(newFactoryComponent?.options);
      if(resultCreateComponent?.id){
        newFactoryComponent.configure({id: resultCreateComponent.id, style: resultCreateComponent?.style || ''});
      }
      //targetComponents.push(newFactoryComponent);
      emit('updateComponents');
      selectedComponent.value = newFactoryComponent;
    }
  }
  catch (e) { notifyManager.error(e?.message || e); }
  finally { LoadingManager.getInstance().stop(); }
};

const duplicateComponent = async (component: IComponentFactory) => {
  if (component) {

    await addComponent(component, components.value);
    //TODO devo duplicare tutti i componenti contenuti al suo interno
    let newComponentOptions: IDroppableComponent = component?.options && JSON.parse(JSON.stringify(component?.options)) || {};
    newComponentOptions.className = (component?.options?.className || '').replace('selectedComponent', '');
    const newComponent: IComponentFactory = componentFactory.value.createElement(newComponentOptions);

    if(Object.keys(newComponent).length>0){
      components.value = [...components.value, newComponent];
      if (newComponent?.options?.slot?.options) {
        await duplicateComponent(newComponent.options.slot);
      }

    }
  }
};

const removeComponent = async (index?: string): boolean => {
  try{
    LoadingManager.getInstance().start();

    if (!index) {
      index = components.value.findIndex(x => x.options.id === selectedComponent.value?.options?.id);
    }

    if(index>=0){
      await componentService.deleteComponent(components.value[index]?.options?.id);
      selectedComponent.value = {};
      if(selectedFile.value.id){
        emit('updateComponents');
      }
      return true
    }
  } catch (e) {
    notifyManager.error(e);
    return false;
  } finally {
    LoadingManager.getInstance().stop();
  }
};

const onDrop = (event: any) => {
  event.preventDefault();

  if(!selectedProject) return;

  const dropTarget = event.target.closest('[data-drop-target]');
  let componentData = event.dataTransfer.getData('component');
  componentData = componentData && componentData?.trim() !== '' && JSON.parse(componentData);

  if (componentData.fromEditor) return;

  let draggedComponent;
  if (componentData.fromDroppableComponent) {
    if (componentData.parentComponentId) {
      const pathToComponent = DragDropHelper.findObjectById(components.value, componentData.parentComponentId);
      if (pathToComponent !== null) {
        if (componentData.component) {
          draggedComponent = componentData.component;
          DragDropHelper.removeObjectByPath(components.value, pathToComponent, componentData.index);
        }
      }
    } else {
      const pathToComponent = DragDropHelper.findObjectById(components.value, componentData.id);
      if (pathToComponent !== null) {
        draggedComponent = JSON.parse(JSON.stringify(DragDropHelper.removeObjectByPath(components.value, pathToComponent)));
      }
    }
  } else {
    draggedComponent = componentData?.slot ? componentData : componentData;
  }

  if (draggedComponent) {
    if (dropTarget && dropTarget.dataset.dropTarget === 'editor') {
      //components.value['tag'] = null;
      addComponent(draggedComponent, components.value);
    }
  }
};

const onDragStart = (event: any, index: number) => {
  let componentData = event.dataTransfer.getData('component');
  componentData = componentData && JSON.parse(componentData);
  if (!componentData.fromDroppableComponent) {
    draggedComponentIndex.value = index;
    draggedFrom.value = 'index';
    event.dataTransfer.setData('component', JSON.stringify({ fromEditor: true, ...components.value[index] }));
  }
};

const onDragEnter = (index: number) => dragOverIndex.value = index;

const onDragLeave = () => dragOverIndex.value = null;

const onDragOver = (event: any) => event.preventDefault();

const onDropComponent = (index: number) => {
  if (draggedComponentIndex.value !== null) {
    const draggedItem = components.value.splice(draggedComponentIndex.value, 1)[0];
    if (index) {
      components.value.splice(index, 0, draggedItem);
    } else {
      const insertIndex = Math.min(index, draggedComponentIndex.value);
      components.value.splice(insertIndex, 0, draggedItem);
    }
    draggedComponentIndex.value = null;
    dragOverIndex.value = null;
  }
};


const removeDraggedComponent = (event: any) => {
  if (!event) return;

  const cmpId = event?.options?.parentComponentId ? event?.options?.parentComponentId : event?.options?.id;
  const index = event.draggedIndex;
  const pathToComponent = DragDropHelper.findObjectById(components.value, cmpId?.toString() || Date.now());
  if (pathToComponent !== null) {
    if (event?.options?.parentComponentId && index >= 0) {
      DragDropHelper.removeObjectByPath(components.value, pathToComponent, index);
    } else {
      DragDropHelper.removeObjectByPath(components.value, pathToComponent)
    }
  }
};

const updateNestedComponents = (id: string, nestedComponents: IComponentFactory[]) => {
  const updateComponents = (componentsArray: IComponentFactory[]) => {
    for (const component of componentsArray) {
      if (component?.options?.id?.toString() === id) {
        component.options.slot = nestedComponents;
        return componentsArray;
      }
      if (component?.options?.slot !== undefined) {
        updateComponents(component.options.slot);
      }
    }
  };
  updateComponents(components.value);
};

const handleComponentClick = async (component: IComponentFactory) => {
  selectedComponent.value = component;
};

const handleComponentRightClick = (event: any, component: IComponentFactory) => {
  contextMenu.value.hide();
  nextTick(() => {
    selectedComponent.value = component;
    contextMenu.value.show(event);
  });
};

function buildComponentTree(components: IComponentFactory[]): IComponentFactory[] {
  const componentMap: { [key: number]: IComponentFactory } = {};
  const tree: IComponentFactory[] = [];

  // Crea una mappa dei componenti per ID
  components.forEach((component) => {
    componentMap[component.options.id] = component;
    component.options.slot = [];  // Inizializza lo slot per i figli
  });

  // Assegna i componenti figli al loro genitore
  components.forEach((component) => {
    if (component.options.parentId) {
      const parent = componentMap[component.options.parentId];
      if (parent) {
        parent.options.slot.push(component);
      }
    } else {
      // Se non ha un genitore, Ã¨ un componente radice
      tree.push(component);
    }
  });

  return tree;
}

onMounted(async () => {
  const handleKeyDown = (event: KeyboardEvent) => {
    if (event.key === 'Delete') {
      event.preventDefault();
      removeComponent();
    }
  };

  window.addEventListener('keydown', handleKeyDown);

  onUnmounted(() => {
    window.removeEventListener('keydown', handleKeyDown);
  });
});
</script>

<template>
  <ContextMenu ref="contextMenu" :model="itemsContextComponent" />

  <div
      class="drop-area"
      @drop="onDrop"
      @dragover="onDragOver"
      data-drop-target="editor"
      data-component-id="editor"
  >
    <div
        v-for="(component, index) in components"
        :key="`${component?.options?.id}-${index}`"
        :class="{'selectedComponent': selectedComponent?.options?.id === component?.options?.id,}"
        class="draggable-component"
        @drop="onDropComponent(index)"
        draggable="true"
        @dragstart="!component?.options?.locked ? onDragStart($event, index) : ''"
        @dragenter="onDragEnter(index)"
        @dragleave="onDragLeave()"
        @contextmenu.stop="handleComponentClick(component); handleComponentRightClick($event);"
    >

      <template v-if="component.options?.name==='DroppableComponent'">
        <DroppableComponent
            :attributes="component?.options?.attributes"
            :component-id="component?.options?.id as string"
            :parent-components="component.options.slot"
            :parent-component-id="component.options.parentId"
            :fileId="selectedFile?.id"
            v-model:selectedComponent="selectedComponent.options"
            v-model:component-factory="componentFactory"
            @updateSelectedComponent="handleComponentClick"
            @updateNestedComponents="updateNestedComponents"
            @removeComponent="removeDraggedComponent($event)"
            @contextmenu.stop="!component?.options?.locked ? handleComponentRightClick($event, component): ''"
            @click.stop="handleComponentClick(component)"
        />


      </template>
<!--      TODO gestire la parte dell'inner. es non funziona l'icon dei bottoni-->
      <template v-else>
        <component
            v-model:selectedComponent="selectedComponent"
            :is="component.render()"
            :class="{[component?.options?.class]: component?.options?.class?.length}"
            :style="component?.options?.style"
            :componentId="component?.options?.id"
            :parentComponents="component?.options?.children"
            v-bind="ProjectHelper.getBindAttributes(component.options as DroppableProps) || {}"
            @updateSelectedComponent="handleComponentClick"
            @updateNestedComponents="updateNestedComponents"
            @removeComponent="removeDraggedComponent($event)"
            @contextmenu.stop="!component?.options?.locked ? handleComponentRightClick($event, component): ''"
            @click.stop="handleComponentClick(component)"
        >{{ component.options?.inner }}</component>
      </template>

    </div>
  </div>
</template>

<style lang="scss" scoped>
</style>